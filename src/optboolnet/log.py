from __future__ import annotations
import json
import os
from typing import Any, Dict, List, Tuple, TYPE_CHECKING
import logging
import enum
from typing import Callable
import time
from optboolnet.boolnet import Control
from optboolnet.config import LoggingConfig

if TYPE_CHECKING:
    from optboolnet.model import CoreIP, Model
    from optboolnet.algorithm import BendersAttractorControl


class EnumCutType(enum.Enum):
    """The indicator of cut types generated by a solver

    Args:
        Enum (int): indicator
    """

    MINIMALITY = 0
    NO_GOOD_MASTER = 1
    NO_GOOD_LOWER_LEVEL = 2
    ATTRACTOR_CUT = 3
    TRAP_SPACE_CUT = 4


class EnumBendersStep(enum.Enum):
    """The indicator of steps in the Benders algorithm

    Args:
        Enum (int): indicator
    """

    BUILD_MODEL = 0
    FORBIDDEN_TRAP_SPACE_CUT = 1
    BENDERS_MASTER = 2
    LOWER_LEVEL_PROBLEM = 3
    SEPARATION_PROBLEM = 4
    FINISHED = 5
    FULL_BILEVEL = 6


class BendersCutFormatter(logging.Formatter):
    def __init__(self, **kwds) -> None:
        super().__init__(**kwds)


class BendersLogger:
    build_logger: logging.Logger
    solve_logger: logging.Logger
    cut_logger: logging.Logger

    build_log_columns = [
        "timestamp",
        "experiment",
        "level",
        "step",
        "model",
        "build_time",
    ]
    solve_log_columns = [
        "timestamp",
        "experiment",
        "level",
        "step",
        "model",
        "solve_time",
        "feasible",
    ]
    cut_log_columns = [
        "timestamp",
        "experiment",
        "level",
        "step",
        "cut_type",
        "cut_strength",
    ]

    config: LoggingConfig

    def __init__(self, _config: LoggingConfig) -> None:
        self.config = _config
        self.start_time = time.time()
        self.is_on = self.config.fpath != ""
        if self.config.fpath != "":
            if not os.path.exists(self.config.fpath):  # making a directory
                os.makedirs(self.config.fpath)
            for log_type in ["build", "solve", "cut"]:
                _logger = logging.getLogger(f"optboolnet.benders.{log_type}")
                _logger.setLevel(logging.INFO)
                for _old_handler in _logger.handlers:
                    _logger.removeHandler(_old_handler)
                self.__setattr__(f"{log_type}_logger", _logger)
                fhdler = logging.FileHandler(
                    f"{self.config.fpath}/log_{self.config.fname}_{log_type}.txt"
                )
                fhdler.setFormatter(logging.Formatter(f"%(levelname)s,%(message)s"))
                _logger.addHandler(fhdler)
            self.write_header()

    def write_header(self):
        self.build_logger.info(",".join(self.build_log_columns))
        self.solve_logger.info(",".join(self.solve_log_columns))
        self.cut_logger.info(",".join(self.cut_log_columns))

    @property
    def elapsed_time(self):
        return time.time() - self.start_time

    def write_controls_to_json(self, sol_dict: Dict[int, List[Control]]):
        if self.is_on:
            with open(f"{self.config.fpath}/sol.json", "w") as _f:
                json.dump(sol_dict, _f)

    def solve_logger_info(self, msg: str):
        if self.is_on:
            self.solve_logger.info(msg)

    @staticmethod
    def wrap_cut(func: Callable):
        def wrapper(_model: BendersAttractorControl, *args):
            result: Tuple[EnumCutType, int] = func(_model, *args)
            if _model.logger.is_on:
                _model.logger.cut_logger.info(
                    f"{_model.log_signature},{result[0].name},{result[1]}"
                )

            return result

        return wrapper

    @staticmethod
    def wrap_model_build(
        func: Callable[[BendersAttractorControl, type[Model], Any], type[Model]]
    ):
        def wrapper(_model: BendersAttractorControl, *args):
            _st = time.time()
            result = func(_model, *args)
            if _model.logger.is_on:
                _model.logger.build_logger.info(
                    f"{_model.log_signature},{result.name},{time.time()-_st:.3f}"
                )
            return result

        return wrapper

    @staticmethod
    def wrap_model_optimize(func: Callable):
        def wrapper(_model: BendersAttractorControl, problem: CoreIP):
            _st = time.time()
            result: CoreIP = func(_model, problem)
            if _model.logger.is_on:
                _model.logger.solve_logger.info(
                    f"{_model.log_signature},{problem.name},{time.time()-_st:.3f},{result}"
                )
            return result

        return wrapper
